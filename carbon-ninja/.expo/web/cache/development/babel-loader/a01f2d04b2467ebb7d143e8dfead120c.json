{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport invariant from 'invariant';\nimport { CameraType, ImageType } from \"./Camera.types\";\nimport * as CapabilityUtils from \"./WebCapabilityUtils\";\nimport { CameraTypeToFacingMode, ImageTypeFormat, MinimumConstraints } from \"./WebConstants\";\nimport { requestUserMediaAsync } from \"./WebUserMediaManager\";\nexport function getImageSize(videoWidth, videoHeight, scale) {\n  var width = videoWidth * scale;\n  var ratio = videoWidth / width;\n  var height = videoHeight / ratio;\n  return {\n    width: width,\n    height: height\n  };\n}\nexport function toDataURL(canvas, imageType, quality) {\n  invariant(Object.values(ImageType).includes(imageType), \"expo-camera: \" + imageType + \" is not a valid ImageType. Expected a string from: \" + Object.values(ImageType).join(', '));\n  var format = ImageTypeFormat[imageType];\n\n  if (imageType === ImageType.jpg) {\n    invariant(quality <= 1 && quality >= 0, \"expo-camera: \" + quality + \" is not a valid image quality. Expected a number from 0...1\");\n    return canvas.toDataURL(format, quality);\n  } else {\n    return canvas.toDataURL(format);\n  }\n}\nexport function hasValidConstraints(preferredCameraType, width, height) {\n  return preferredCameraType !== undefined && width !== undefined && height !== undefined;\n}\n\nfunction ensureCameraPictureOptions(config) {\n  var captureOptions = {\n    scale: 1,\n    imageType: ImageType.png,\n    isImageMirror: false\n  };\n\n  for (var key in config) {\n    if (key in config && config[key] !== undefined && key in captureOptions) {\n      captureOptions[key] = config[key];\n    }\n  }\n\n  return captureOptions;\n}\n\nvar DEFAULT_QUALITY = 0.92;\nexport function captureImageData(video) {\n  var pictureOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {\n    return null;\n  }\n\n  var canvas = captureImageContext(video, pictureOptions);\n  var context = canvas.getContext('2d', {\n    alpha: false\n  });\n\n  if (!context || !canvas.width || !canvas.height) {\n    return null;\n  }\n\n  var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  return imageData;\n}\nexport function captureImageContext(video, _ref) {\n  var _ref$scale = _ref.scale,\n      scale = _ref$scale === void 0 ? 1 : _ref$scale,\n      _ref$isImageMirror = _ref.isImageMirror,\n      isImageMirror = _ref$isImageMirror === void 0 ? false : _ref$isImageMirror;\n  var videoWidth = video.videoWidth,\n      videoHeight = video.videoHeight;\n\n  var _getImageSize = getImageSize(videoWidth, videoHeight, scale),\n      width = _getImageSize.width,\n      height = _getImageSize.height;\n\n  var canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  var context = canvas.getContext('2d', {\n    alpha: false\n  });\n\n  if (!context) {\n    throw new Error('Context is not defined');\n  }\n\n  if (isImageMirror) {\n    context.setTransform(-1, 0, 0, 1, canvas.width, 0);\n  }\n\n  context.drawImage(video, 0, 0, width, height);\n  return canvas;\n}\nexport function captureImage(video, pictureOptions) {\n  var config = ensureCameraPictureOptions(pictureOptions);\n  var canvas = captureImageContext(video, config);\n  var imageType = config.imageType,\n      _config$quality = config.quality,\n      quality = _config$quality === void 0 ? DEFAULT_QUALITY : _config$quality;\n  return toDataURL(canvas, imageType, quality);\n}\n\nfunction getSupportedConstraints() {\n  if (navigator.mediaDevices && navigator.mediaDevices.getSupportedConstraints) {\n    return navigator.mediaDevices.getSupportedConstraints();\n  }\n\n  return null;\n}\n\nexport function getIdealConstraints(preferredCameraType, width, height) {\n  var preferredConstraints = {\n    audio: false,\n    video: {}\n  };\n\n  if (hasValidConstraints(preferredCameraType, width, height)) {\n    return MinimumConstraints;\n  }\n\n  var supports = getSupportedConstraints();\n\n  if (!supports || !supports.facingMode || !supports.width || !supports.height) {\n    return MinimumConstraints;\n  }\n\n  if (preferredCameraType && Object.values(CameraType).includes(preferredCameraType)) {\n    var facingMode = CameraTypeToFacingMode[preferredCameraType];\n\n    if (isWebKit()) {\n      var key = facingMode === 'user' ? 'exact' : 'ideal';\n      preferredConstraints.video.facingMode = _defineProperty({}, key, facingMode);\n    } else {\n      preferredConstraints.video.facingMode = {\n        ideal: CameraTypeToFacingMode[preferredCameraType]\n      };\n    }\n  }\n\n  if (isMediaTrackConstraints(preferredConstraints.video)) {\n    preferredConstraints.video.width = width;\n    preferredConstraints.video.height = height;\n  }\n\n  return preferredConstraints;\n}\n\nfunction isMediaTrackConstraints(input) {\n  return input && typeof input.video !== 'boolean';\n}\n\nexport function getPreferredStreamDevice(preferredCameraType, preferredWidth, preferredHeight) {\n  var nextCameraType;\n  return _regeneratorRuntime.async(function getPreferredStreamDevice$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.prev = 0;\n          _context.next = 3;\n          return _regeneratorRuntime.awrap(getStreamDevice(preferredCameraType, preferredWidth, preferredHeight));\n\n        case 3:\n          return _context.abrupt(\"return\", _context.sent);\n\n        case 6:\n          _context.prev = 6;\n          _context.t0 = _context[\"catch\"](0);\n\n          if (!(_context.t0 instanceof OverconstrainedError && _context.t0.constraint === 'facingMode')) {\n            _context.next = 13;\n            break;\n          }\n\n          nextCameraType = preferredCameraType === CameraType.back ? CameraType.front : CameraType.back;\n          _context.next = 12;\n          return _regeneratorRuntime.awrap(getStreamDevice(nextCameraType, preferredWidth, preferredHeight));\n\n        case 12:\n          return _context.abrupt(\"return\", _context.sent);\n\n        case 13:\n          throw _context.t0;\n\n        case 14:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[0, 6]], Promise);\n}\nexport function getStreamDevice(preferredCameraType, preferredWidth, preferredHeight) {\n  var constraints, stream;\n  return _regeneratorRuntime.async(function getStreamDevice$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          constraints = getIdealConstraints(preferredCameraType, preferredWidth, preferredHeight);\n          _context2.next = 3;\n          return _regeneratorRuntime.awrap(requestUserMediaAsync(constraints));\n\n        case 3:\n          stream = _context2.sent;\n          return _context2.abrupt(\"return\", stream);\n\n        case 5:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function isWebKit() {\n  return /WebKit/.test(navigator.userAgent) && !/Edg/.test(navigator.userAgent);\n}\nexport function compareStreams(a, b) {\n  if (!a || !b) {\n    return false;\n  }\n\n  var settingsA = a.getTracks()[0].getSettings();\n  var settingsB = b.getTracks()[0].getSettings();\n  return settingsA.deviceId === settingsB.deviceId;\n}\nexport function capture(video, settings, config) {\n  var base64 = captureImage(video, config);\n  var capturedPicture = {\n    uri: base64,\n    base64: base64,\n    width: 0,\n    height: 0\n  };\n\n  if (settings) {\n    var _settings$width = settings.width,\n        width = _settings$width === void 0 ? 0 : _settings$width,\n        _settings$height = settings.height,\n        height = _settings$height === void 0 ? 0 : _settings$height;\n    capturedPicture.width = width;\n    capturedPicture.height = height;\n    capturedPicture.exif = settings;\n  }\n\n  if (config.onPictureSaved) {\n    config.onPictureSaved(capturedPicture);\n  }\n\n  return capturedPicture;\n}\nexport function syncTrackCapabilities(cameraType, stream) {\n  var settings,\n      _args3 = arguments;\n  return _regeneratorRuntime.async(function syncTrackCapabilities$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          settings = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};\n\n          if (!(stream != null && stream.getVideoTracks)) {\n            _context3.next = 4;\n            break;\n          }\n\n          _context3.next = 4;\n          return _regeneratorRuntime.awrap(Promise.all(stream.getVideoTracks().map(function (track) {\n            return onCapabilitiesReady(cameraType, track, settings);\n          })));\n\n        case 4:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction onCapabilitiesReady(cameraType, track) {\n  var settings,\n      capabilities,\n      constraints,\n      clampedValues,\n      _i,\n      _clampedValues,\n      property,\n      validatedInternalConstrainedValue,\n      _args4 = arguments;\n\n  return _regeneratorRuntime.async(function onCapabilitiesReady$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          validatedInternalConstrainedValue = function _validatedInternalCon(constraintKey, settingsKey, converter) {\n            var convertedSetting = converter(settings[settingsKey]);\n            return validatedConstrainedValue({\n              constraintKey: constraintKey,\n              settingsKey: settingsKey,\n              convertedSetting: convertedSetting,\n              capabilities: capabilities,\n              settings: settings,\n              cameraType: cameraType\n            });\n          };\n\n          settings = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};\n          capabilities = track.getCapabilities();\n          constraints = {};\n          clampedValues = ['exposureCompensation', 'colorTemperature', 'iso', 'brightness', 'contrast', 'saturation', 'sharpness', 'focusDistance', 'zoom'];\n\n          for (_i = 0, _clampedValues = clampedValues; _i < _clampedValues.length; _i++) {\n            property = _clampedValues[_i];\n\n            if (capabilities[property]) {\n              constraints[property] = convertNormalizedSetting(capabilities[property], settings[property]);\n            }\n          }\n\n          if (capabilities.focusMode && settings.autoFocus !== undefined) {\n            constraints.focusMode = validatedInternalConstrainedValue('focusMode', 'autoFocus', CapabilityUtils.convertAutoFocusJSONToNative);\n          }\n\n          if (capabilities.torch && settings.flashMode !== undefined) {\n            constraints.torch = validatedInternalConstrainedValue('torch', 'flashMode', CapabilityUtils.convertFlashModeJSONToNative);\n          }\n\n          if (capabilities.whiteBalanceMode && settings.whiteBalance !== undefined) {\n            constraints.whiteBalanceMode = validatedInternalConstrainedValue('whiteBalanceMode', 'whiteBalance', CapabilityUtils.convertWhiteBalanceJSONToNative);\n          }\n\n          _context4.prev = 9;\n          _context4.next = 12;\n          return _regeneratorRuntime.awrap(track.applyConstraints({\n            advanced: [constraints]\n          }));\n\n        case 12:\n          _context4.next = 17;\n          break;\n\n        case 14:\n          _context4.prev = 14;\n          _context4.t0 = _context4[\"catch\"](9);\n          if (__DEV__) console.warn('Failed to apply constraints', _context4.t0);\n\n        case 17:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, [[9, 14]], Promise);\n}\n\nexport function stopMediaStream(stream) {\n  if (!stream) {\n    return;\n  }\n\n  if (stream.getAudioTracks) {\n    stream.getAudioTracks().forEach(function (track) {\n      return track.stop();\n    });\n  }\n\n  if (stream.getVideoTracks) {\n    stream.getVideoTracks().forEach(function (track) {\n      return track.stop();\n    });\n  }\n\n  if (isMediaStreamTrack(stream)) {\n    stream.stop();\n  }\n}\nexport function setVideoSource(video, stream) {\n  var _window$URL$createObj;\n\n  var createObjectURL = (_window$URL$createObj = window.URL.createObjectURL) != null ? _window$URL$createObj : window.webkitURL.createObjectURL;\n\n  if (typeof video.srcObject !== 'undefined') {\n    video.srcObject = stream;\n  } else if (typeof video.mozSrcObject !== 'undefined') {\n    video.mozSrcObject = stream;\n  } else if (stream && createObjectURL) {\n    video.src = createObjectURL(stream);\n  }\n\n  if (!stream) {\n    var _window$URL$revokeObj, _ref2, _video$src;\n\n    var revokeObjectURL = (_window$URL$revokeObj = window.URL.revokeObjectURL) != null ? _window$URL$revokeObj : window.webkitURL.revokeObjectURL;\n    var source = (_ref2 = (_video$src = video.src) != null ? _video$src : video.srcObject) != null ? _ref2 : video.mozSrcObject;\n\n    if (revokeObjectURL && typeof source === 'string') {\n      revokeObjectURL(source);\n    }\n  }\n}\nexport function isCapabilityAvailable(video, keyName) {\n  var stream = video.srcObject;\n\n  if (stream instanceof MediaStream) {\n    var _videoTrack$getCapabi;\n\n    var videoTrack = stream.getVideoTracks()[0];\n    return videoTrack.getCapabilities == null ? void 0 : (_videoTrack$getCapabi = videoTrack.getCapabilities()) == null ? void 0 : _videoTrack$getCapabi[keyName];\n  }\n\n  return false;\n}\n\nfunction isMediaStreamTrack(input) {\n  return typeof input.stop === 'function';\n}\n\nfunction convertNormalizedSetting(range, value) {\n  if (!value) {\n    return;\n  }\n\n  var converted = convertRange(value, [range.min, range.max]);\n  return Math.min(range.max, Math.max(range.min, converted));\n}\n\nfunction convertRange(value, r2) {\n  var r1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 1];\n  return (value - r1[0]) * (r2[1] - r2[0]) / (r1[1] - r1[0]) + r2[0];\n}\n\nfunction validatedConstrainedValue(props) {\n  var constraintKey = props.constraintKey,\n      settingsKey = props.settingsKey,\n      convertedSetting = props.convertedSetting,\n      capabilities = props.capabilities,\n      settings = props.settings,\n      cameraType = props.cameraType;\n  var setting = settings[settingsKey];\n\n  if (Array.isArray(capabilities[constraintKey]) && convertedSetting && !capabilities[constraintKey].includes(convertedSetting)) {\n    if (__DEV__) {\n      console.warn(\" { \" + settingsKey + \": \\\"\" + setting + \"\\\" } (converted to \\\"\" + convertedSetting + \"\\\" in the browser) is not supported for camera type \\\"\" + cameraType + \"\\\" in your browser. Using the default value instead.\");\n    }\n\n    return undefined;\n  }\n\n  return convertedSetting;\n}","map":{"version":3,"sources":["../src/WebCameraUtils.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-env browser */\nimport invariant from 'invariant';\n\nimport {\n  CameraType,\n  CapturedPicture,\n  ImageSize,\n  ImageType,\n  WebCameraSettings,\n  CameraPictureOptions,\n} from './Camera.types';\nimport * as CapabilityUtils from './WebCapabilityUtils';\nimport { CameraTypeToFacingMode, ImageTypeFormat, MinimumConstraints } from './WebConstants';\nimport { requestUserMediaAsync } from './WebUserMediaManager';\n\ninterface ConstrainLongRange {\n  max?: number;\n  min?: number;\n  exact?: number;\n  ideal?: number;\n}\n\nexport function getImageSize(videoWidth: number, videoHeight: number, scale: number): ImageSize {\n  const width = videoWidth * scale;\n  const ratio = videoWidth / width;\n  const height = videoHeight / ratio;\n\n  return {\n    width,\n    height,\n  };\n}\n\nexport function toDataURL(\n  canvas: HTMLCanvasElement,\n  imageType: ImageType,\n  quality: number\n): string {\n  invariant(\n    Object.values(ImageType).includes(imageType),\n    `expo-camera: ${imageType} is not a valid ImageType. Expected a string from: ${Object.values(\n      ImageType\n    ).join(', ')}`\n  );\n\n  const format = ImageTypeFormat[imageType];\n  if (imageType === ImageType.jpg) {\n    invariant(\n      quality <= 1 && quality >= 0,\n      `expo-camera: ${quality} is not a valid image quality. Expected a number from 0...1`\n    );\n    return canvas.toDataURL(format, quality);\n  } else {\n    return canvas.toDataURL(format);\n  }\n}\n\nexport function hasValidConstraints(\n  preferredCameraType?: CameraType,\n  width?: number | ConstrainLongRange,\n  height?: number | ConstrainLongRange\n): boolean {\n  return preferredCameraType !== undefined && width !== undefined && height !== undefined;\n}\n\nfunction ensureCameraPictureOptions(config: CameraPictureOptions): CameraPictureOptions {\n  const captureOptions = {\n    scale: 1,\n    imageType: ImageType.png,\n    isImageMirror: false,\n  };\n\n  for (const key in config) {\n    if (key in config && config[key] !== undefined && key in captureOptions) {\n      captureOptions[key] = config[key];\n    }\n  }\n  return captureOptions;\n}\n\nconst DEFAULT_QUALITY = 0.92;\n\nexport function captureImageData(\n  video: HTMLVideoElement | null,\n  pictureOptions: Pick<CameraPictureOptions, 'scale' | 'isImageMirror'> = {}\n): ImageData | null {\n  if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {\n    return null;\n  }\n  const canvas = captureImageContext(video, pictureOptions);\n\n  const context = canvas.getContext('2d', { alpha: false });\n  if (!context || !canvas.width || !canvas.height) {\n    return null;\n  }\n\n  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  return imageData;\n}\n\nexport function captureImageContext(\n  video: HTMLVideoElement,\n  { scale = 1, isImageMirror = false }: Pick<CameraPictureOptions, 'scale' | 'isImageMirror'>\n): HTMLCanvasElement {\n  const { videoWidth, videoHeight } = video;\n  const { width, height } = getImageSize(videoWidth, videoHeight, scale!);\n\n  // Build the canvas size and draw the camera image to the context from video\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const context = canvas.getContext('2d', { alpha: false });\n\n  if (!context) {\n    // Should never be called\n    throw new Error('Context is not defined');\n  }\n  // sharp image details\n  // context.imageSmoothingEnabled = false;\n\n  // Flip horizontally (as css transform: rotateY(180deg))\n  if (isImageMirror) {\n    context.setTransform(-1, 0, 0, 1, canvas.width, 0);\n  }\n\n  context.drawImage(video, 0, 0, width, height);\n\n  return canvas;\n}\n\nexport function captureImage(\n  video: HTMLVideoElement,\n  pictureOptions: CameraPictureOptions\n): string {\n  const config = ensureCameraPictureOptions(pictureOptions);\n  const canvas = captureImageContext(video, config);\n  const { imageType, quality = DEFAULT_QUALITY } = config;\n  return toDataURL(canvas, imageType!, quality);\n}\n\nfunction getSupportedConstraints(): MediaTrackSupportedConstraints | null {\n  if (navigator.mediaDevices && navigator.mediaDevices.getSupportedConstraints) {\n    return navigator.mediaDevices.getSupportedConstraints();\n  }\n  return null;\n}\n\nexport function getIdealConstraints(\n  preferredCameraType: CameraType,\n  width?: number | ConstrainLongRange,\n  height?: number | ConstrainLongRange\n): MediaStreamConstraints {\n  const preferredConstraints: MediaStreamConstraints = {\n    audio: false,\n    video: {},\n  };\n\n  if (hasValidConstraints(preferredCameraType, width, height)) {\n    return MinimumConstraints;\n  }\n\n  const supports = getSupportedConstraints();\n  // TODO(Bacon): Test this\n  if (!supports || !supports.facingMode || !supports.width || !supports.height) {\n    return MinimumConstraints;\n  }\n\n  if (preferredCameraType && Object.values(CameraType).includes(preferredCameraType)) {\n    const facingMode = CameraTypeToFacingMode[preferredCameraType];\n    if (isWebKit()) {\n      const key = facingMode === 'user' ? 'exact' : 'ideal';\n      (preferredConstraints.video as MediaTrackConstraints).facingMode = {\n        [key]: facingMode,\n      };\n    } else {\n      (preferredConstraints.video as MediaTrackConstraints).facingMode = {\n        ideal: CameraTypeToFacingMode[preferredCameraType],\n      };\n    }\n  }\n\n  if (isMediaTrackConstraints(preferredConstraints.video)) {\n    preferredConstraints.video.width = width;\n    preferredConstraints.video.height = height;\n  }\n\n  return preferredConstraints;\n}\n\nfunction isMediaTrackConstraints(input: any): input is MediaTrackConstraints {\n  return input && typeof input.video !== 'boolean';\n}\n\n/**\n * Invoke getStreamDevice a second time with the opposing camera type if the preferred type cannot be retrieved.\n *\n * @param preferredCameraType\n * @param preferredWidth\n * @param preferredHeight\n */\nexport async function getPreferredStreamDevice(\n  preferredCameraType: CameraType,\n  preferredWidth?: number | ConstrainLongRange,\n  preferredHeight?: number | ConstrainLongRange\n): Promise<MediaStream> {\n  try {\n    return await getStreamDevice(preferredCameraType, preferredWidth, preferredHeight);\n  } catch (error) {\n    // A hack on desktop browsers to ensure any camera is used.\n    // eslint-disable-next-line no-undef\n    if (error instanceof OverconstrainedError && error.constraint === 'facingMode') {\n      const nextCameraType =\n        preferredCameraType === CameraType.back ? CameraType.front : CameraType.back;\n      return await getStreamDevice(nextCameraType, preferredWidth, preferredHeight);\n    }\n    throw error;\n  }\n}\n\nexport async function getStreamDevice(\n  preferredCameraType: CameraType,\n  preferredWidth?: number | ConstrainLongRange,\n  preferredHeight?: number | ConstrainLongRange\n): Promise<MediaStream> {\n  const constraints: MediaStreamConstraints = getIdealConstraints(\n    preferredCameraType,\n    preferredWidth,\n    preferredHeight\n  );\n  const stream: MediaStream = await requestUserMediaAsync(constraints);\n  return stream;\n}\n\nexport function isWebKit(): boolean {\n  return /WebKit/.test(navigator.userAgent) && !/Edg/.test(navigator.userAgent);\n}\n\nexport function compareStreams(a: MediaStream | null, b: MediaStream | null): boolean {\n  if (!a || !b) {\n    return false;\n  }\n  const settingsA = a.getTracks()[0].getSettings();\n  const settingsB = b.getTracks()[0].getSettings();\n  return settingsA.deviceId === settingsB.deviceId;\n}\n\nexport function capture(\n  video: HTMLVideoElement,\n  settings: MediaTrackSettings,\n  config: CameraPictureOptions\n): CapturedPicture {\n  const base64 = captureImage(video, config);\n\n  const capturedPicture: CapturedPicture = {\n    uri: base64,\n    base64,\n    width: 0,\n    height: 0,\n  };\n\n  if (settings) {\n    const { width = 0, height = 0 } = settings;\n    capturedPicture.width = width;\n    capturedPicture.height = height;\n    capturedPicture.exif = settings;\n  }\n\n  if (config.onPictureSaved) {\n    config.onPictureSaved(capturedPicture);\n  }\n  return capturedPicture;\n}\n\nexport async function syncTrackCapabilities(\n  cameraType: CameraType,\n  stream: MediaStream | null,\n  settings: WebCameraSettings = {}\n): Promise<void> {\n  if (stream?.getVideoTracks) {\n    await Promise.all(\n      stream.getVideoTracks().map(track => onCapabilitiesReady(cameraType, track, settings))\n    );\n  }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints\nasync function onCapabilitiesReady(\n  cameraType: CameraType,\n  track: MediaStreamTrack,\n  settings: WebCameraSettings = {}\n): Promise<void> {\n  const capabilities = track.getCapabilities();\n\n  // Create an empty object because if you set a constraint that isn't available an error will be thrown.\n  const constraints: MediaTrackConstraintSet = {};\n\n  // TODO(Bacon): Add `pointsOfInterest` support\n  const clampedValues = [\n    'exposureCompensation',\n    'colorTemperature',\n    'iso',\n    'brightness',\n    'contrast',\n    'saturation',\n    'sharpness',\n    'focusDistance',\n    'zoom',\n  ];\n\n  for (const property of clampedValues) {\n    if (capabilities[property]) {\n      constraints[property] = convertNormalizedSetting(capabilities[property], settings[property]);\n    }\n  }\n\n  function validatedInternalConstrainedValue<IConvertedType>(\n    constraintKey: string,\n    settingsKey: string,\n    converter: (settingValue: any) => IConvertedType\n  ) {\n    const convertedSetting = converter(settings[settingsKey]);\n    return validatedConstrainedValue({\n      constraintKey,\n      settingsKey,\n      convertedSetting,\n      capabilities,\n      settings,\n      cameraType,\n    });\n  }\n\n  if (capabilities.focusMode && settings.autoFocus !== undefined) {\n    constraints.focusMode = validatedInternalConstrainedValue<MediaTrackConstraintSet['focusMode']>(\n      'focusMode',\n      'autoFocus',\n      CapabilityUtils.convertAutoFocusJSONToNative\n    );\n  }\n\n  if (capabilities.torch && settings.flashMode !== undefined) {\n    constraints.torch = validatedInternalConstrainedValue<MediaTrackConstraintSet['torch']>(\n      'torch',\n      'flashMode',\n      CapabilityUtils.convertFlashModeJSONToNative\n    );\n  }\n\n  if (capabilities.whiteBalanceMode && settings.whiteBalance !== undefined) {\n    constraints.whiteBalanceMode = validatedInternalConstrainedValue<\n      MediaTrackConstraintSet['whiteBalanceMode']\n    >('whiteBalanceMode', 'whiteBalance', CapabilityUtils.convertWhiteBalanceJSONToNative);\n  }\n\n  try {\n    await track.applyConstraints({ advanced: [constraints] });\n  } catch (error) {\n    if (__DEV__) console.warn('Failed to apply constraints', error);\n  }\n}\n\nexport function stopMediaStream(stream: MediaStream | null) {\n  if (!stream) {\n    return;\n  }\n  if (stream.getAudioTracks) {\n    stream.getAudioTracks().forEach(track => track.stop());\n  }\n  if (stream.getVideoTracks) {\n    stream.getVideoTracks().forEach(track => track.stop());\n  }\n  if (isMediaStreamTrack(stream)) {\n    stream.stop();\n  }\n}\n\nexport function setVideoSource(\n  video: HTMLVideoElement,\n  stream: MediaStream | MediaSource | Blob | null\n): void {\n  const createObjectURL = window.URL.createObjectURL ?? window.webkitURL.createObjectURL;\n\n  if (typeof video.srcObject !== 'undefined') {\n    video.srcObject = stream;\n  } else if (typeof (video as any).mozSrcObject !== 'undefined') {\n    (video as any).mozSrcObject = stream;\n  } else if (stream && createObjectURL) {\n    video.src = createObjectURL(stream);\n  }\n\n  if (!stream) {\n    const revokeObjectURL = window.URL.revokeObjectURL ?? window.webkitURL.revokeObjectURL;\n    const source = video.src ?? video.srcObject ?? (video as any).mozSrcObject;\n    if (revokeObjectURL && typeof source === 'string') {\n      revokeObjectURL(source);\n    }\n  }\n}\n\nexport function isCapabilityAvailable(video: HTMLVideoElement, keyName: string): boolean {\n  const stream = video.srcObject;\n\n  if (stream instanceof MediaStream) {\n    const videoTrack = stream.getVideoTracks()[0];\n    return videoTrack.getCapabilities?.()?.[keyName];\n  }\n\n  return false;\n}\n\nfunction isMediaStreamTrack(input: any): input is MediaStreamTrack {\n  return typeof input.stop === 'function';\n}\n\nfunction convertNormalizedSetting(range: MediaSettingsRange, value?: number): number | undefined {\n  if (!value) {\n    return;\n  }\n  // convert the normalized incoming setting to the native camera zoom range\n  const converted = convertRange(value, [range.min, range.max]);\n  // clamp value so we don't get an error\n  return Math.min(range.max, Math.max(range.min, converted));\n}\n\nfunction convertRange(value: number, r2: number[], r1: number[] = [0, 1]): number {\n  return ((value - r1[0]) * (r2[1] - r2[0])) / (r1[1] - r1[0]) + r2[0];\n}\n\nfunction validatedConstrainedValue<T>(props: {\n  constraintKey: string;\n  settingsKey: string;\n  convertedSetting: T;\n  capabilities: MediaTrackCapabilities;\n  settings: WebCameraSettings;\n  cameraType: string;\n}): T | undefined {\n  const {\n    constraintKey,\n    settingsKey,\n    convertedSetting,\n    capabilities,\n    settings,\n    cameraType,\n  } = props;\n  const setting = settings[settingsKey];\n  if (\n    Array.isArray(capabilities[constraintKey]) &&\n    convertedSetting &&\n    !capabilities[constraintKey].includes(convertedSetting)\n  ) {\n    if (__DEV__) {\n      // Only warn in dev mode.\n      console.warn(\n        ` { ${settingsKey}: \"${setting}\" } (converted to \"${convertedSetting}\" in the browser) is not supported for camera type \"${cameraType}\" in your browser. Using the default value instead.`\n      );\n    }\n    return undefined;\n  }\n  return convertedSetting;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}